(require 'json)
(require 'cc-mode)

(defface babylon-jsx-identifier-face2
  '((t :foreground "SlateGray"))
  "The face for JSX identifiers in babylon mode")

(defvar babylon-mode-hook nil)
(defvar babylon-mode-map (make-keymap))
(defvar babylon-mode-syntax-table
  (let ((table (make-syntax-table)))
    (c-populate-syntax-table table)
    ; (modify-syntax-entry ?` "\"" table)
    table))

(defvar babylon-script
  "/home/xymostech/projects/babylon-mode/parse.js")

(defun babylon-set-face (node face &optional ignore-annotation)
  (if (not node)
      (backtrace)
    (let* ((loc (alist-get 'loc node))
           (beg (+ (alist-get 'start node) 1))
           (end (+ (alist-get 'end node) 1))
           (annotationStart (alist-get 'start (alist-get 'typeAnnotation node))))
      (if (and annotationStart ignore-annotation)
          (put-text-property beg (+ annotationStart 1) 'font-lock-face face)
          (put-text-property beg end 'font-lock-face face)))))

(defun babylon-clear-node-face (node)
  (let* ((loc (alist-get 'loc node))
         (beg (+ (alist-get 'start node) 1))
         (end (+ (alist-get 'end node) 1)))
    (babylon-clear-face beg end)))

(defconst babylon-traverse-table
  '(("Program" . (:keys (body directives)))
   ("Function" . (:keys (params body returnType)))
   ("Statement" . ())
   ("ExpressionStatement" . (:keys (expression) :extends ("Statement")))
   ("BlockStatement" . (:keys (body directives) :extends ("Statement")))
   ("WithStatement" . (:keys (body object) :extends ("Statement")))
   ("ReturnStatement" . (:keys (argument) :extends ("Statement")))
   ("Declaration" . (:extends ("Statement")))
   ("VariableDeclaration" . (:keys (declarations) :extends ("Declaration")))
   ("VariableDeclarator" . (:keys (id init)))
   ("Identifier" . (:keys (typeAnnotation)))
   ("StringLiteral" . ())
   ("Declaration" . ())
   ("FunctionDeclaration" . (:keys (id) :extends ("Function" "Declaration")))
   ("Expression" . ())
   ("CallExpression" . (:keys (callee arguments) :extends ("Expression")))
   ("ObjectMember" . (:keys (key value decorators)))
   ("ObjectProperty" . (:extends ("ObjectMember")))
   ("AssignmentProperty" . (:keys (value) :extends ("ObjectProperty")))
   ("AssignmentExpression" . (:keys (left right) :extends ("Expression")))
   ("Pattern" . ())
   ("ObjectPattern" . (:keys (properties) :extends ("Pattern")))
   ("ObjectExpression" . (:keys (properties) :extends ("Expression")))
   ("MemberExpression" . (:keys (object property) :extends ("Expression" "Pattern")))
   ("ArrayExpression" . (:keys (elements) :extends ("Expression")))
   ("FunctionExpression" . (:extends ("Function" "Expression")))
   ("Literal" . (:extends ("Expression")))
   ("RegExpLiteral" . (:extends ("Literal")))
   ("NullLiteral" . (:extends ("Literal")))
   ("StringLiteral" . (:extends ("Literal")))
   ("BooleanLiteral" . (:extends ("Literal")))
   ("NumericLiteral" . (:extends ("Literal")))
   ("ThisExpression" . (:extends ("Expression")))
   ("LogicalExpression" . (:keys (left right) :extends ("Expression")))
   ("IfStatement" . (:keys (test consequent alternate) :extends ("Statement")))
   ("UnaryExpression" . (:keys (argument) :extends ("Expression")))
   ("BinaryExpression" . (:keys (left right) :extends ("Expression")))
   ("ConditionalExpression" . (:keys (test consequent alternate) :extends ("Expression")))
   ("ArrowFunctionExpression" . (:keys (body) :extends ("Function" "Expression")))
   ("ObjectMethod" . (:extends ("ObjectMember" "Function")))
   ("TemplateLiteral" . (:keys (quasis expressions) :extends ("Expression")))
   ("TaggedTemplateExpression" . (:keys (tag quasi) :extends ("Expression")))
   ("TemplateElement" . ())
   ("NewExpression" . (:extends ("CallExpression")))
   ("ArrayPattern" . (:keys (elements) :extends ("Pattern")))
   ("ModuleDeclaration" . ())
   ("ExportNamedDeclaration" . (:keys (declaration specifiers source) :extends ("ModuleDeclaration")))
   ("ExportDefaultDeclaration" . (:keys (declaration) :extends ("ModuleDeclaration")))
   ("Class" . (:keys (id superClass body decorators)))
   ("ClassBody" . (:keys (body)))
   ("ClassMethod" . (:keys (key params body decorators)))
   ("ClassProperty" . (:keys (key value)))
   ("ClassDeclaration" . (:keys (id) :extends ("Class")))
   ("SpreadProperty" . (:keys (argument)))
   ("ImportDeclaration" . (:keys (specifiers source) :extends ("ModuleDeclaration")))
   ("ModuleSpecifier" . (:keys (local)))
   ("ImportSpecifier" . (:keys (imported) :extends ("ModuleSpecifier")))
   ("Import" . (:keys () :extends ("Identifier")))
   ("ImportDefaultSpecifier" . (:extends ("ModuleSpecifier")))
   ("ImportNamespaceSpecifier" . (:extends ("ModuleSpecifier")))
   ("ThrowStatement" . (:keys (argument) :extends ("Statement")))
   ("SpreadElement" . (:keys (argument)))
   ("TryStatement" . (:keys (block handler finalizer) :extends ("Statement")))
   ("CatchClause" . (:keys (param body)))
   ("SwitchStatement" . (:keys (discriminant cases) :extends ("Statement")))
   ("SwitchCase" . (:keys (test consequent)))
   ("AssignmentPattern" . (:keys (left right) :extends ("Pattern")))
   ("DoWhileStatement" . (:keys (body test) :extends ("Statement")))
   ("WhileStatement" . (:keys (body test) :extends ("Statement")))
   ("ForStatement" . (:keys (init test update body) :extends ("Statement")))
   ("UpdateExpression" . (:keys (argument) :extends ("Expression")))
   ("DebuggerStatement" . (:extends ("Statement")))
   ("RestProperty" . (:keys (argument)))
   ("RestElement" . (:keys (argument)))
   ("Super" . ())
   ("ForInStatement" . (:keys (left right body) :extends ("Statement")))
   ("ForOfStatement" . (:extends ("ForInStatement")))
   ("ContinueStatement" . (:extends ("Statement")))
   ("BreakStatement" . (:extends ("Statement")))
   ("AwaitExpression" . (:keys (argument) :extends ("Expression")))

   ("TypeCastExpression" . (:keys (expression typeAnnotation)))
   ("TypeAnnotation" . (:keys (typeAnnotation)))
   ("AnyTypeAnnotation" . ())
   ("StringTypeAnnotation" . ())
   ("MixedTypeAnnotation" . ())
   ("ObjectTypeAnnotation" . (:keys (callProperties properties)))
   ("ObjectTypeProperty" . (:keys (key value)))
   ("TypeAlias" . (:keys (id right)))
   ("NullableTypeAnnotation" . (:keys (typeAnnotation)))
   ("GenericTypeAnnotation" . (:keys (typeParameters id)))
   ("QualifiedTypeIdentifier" . (:keys (qualification id)))
   ("NumberTypeAnnotation" . (:keys (qualification id)))
   ("TypeParameterInstantiation" . (:keys (params)))
   ("FunctionTypeAnnotation" . (:keys (params returnType)))
   ("FunctionTypeParam" . (:keys (name typeAnnotation)))
   ("ExistentialTypeParam" . ())
   ("VoidTypeAnnotation" . ())
   ("NullLiteralTypeAnnotation" . ())
   ("BooleanTypeAnnotation" . ())
   ("ArrayTypeAnnotation" . (:keys (elementType)))
   ("TypeofTypeAnnotation" . (:keys (argument)))
   ("ObjectTypeSpreadProperty" . (:keys (argument)))
   ("UnionTypeAnnotation" . (:keys (types)))
   ("IntersectionTypeAnnotation" . (:keys (types)))
   ("StringLiteralTypeAnnotation" . ())
   ("TupleTypeAnnotation" . (:keys (types)))

   ("JSXElement" . (:keys (openingElement closingElement children)))
   ("JSXOpeningElement" . (:keys (name attributes)))
   ("JSXClosingElement" . (:keys (name)))
   ("JSXText" . ())
   ("JSXExpressionContainer" . (:keys (expression)))
   ("JSXIdentifier" . ())
   ("JSXAttribute" . (:keys (name value)))
   ("JSXMemberExpression" . (:keys (object property)))
   ("JSXSpreadAttribute" . (:keys (argument)))
   ("JSXEmptyExpression" . ())
   ))

(defun babylon-traverse-node-key (node key)
  (let ((val (alist-get key node)))
    (if (vectorp val)
        (seq-do 'babylon-traverse val)
      (babylon-traverse val))))

(defun babylon-handle-traverse-table (node table-entry)
  (let* ((table-val (cdr table-entry))
         (keys (plist-get table-val :keys))
         (supers (plist-get table-val :extends)))
    (seq-do (lambda (key) (babylon-traverse-node-key node key)) keys)
    (seq-do (lambda (super)
              (babylon-handle-traverse-table node (assoc super babylon-traverse-table)))
            supers)))

(defun babylon-traverse (node)
  (if node
      (let* ((node-type (alist-get 'type node))
             (traverse-entry (assoc node-type babylon-traverse-table)))
        (cond ((equal node-type "TypeAnnotation")
               (babylon-set-face node 'font-lock-type-face))
              ((equal node-type "FunctionDeclaration")
               (babylon-set-face (alist-get 'id node) 'font-lock-function-name-face))
              ((equal node-type "TypeAlias")
               (babylon-set-face (alist-get 'id node) 'font-lock-type-face))
              ((or (equal node-type "ImportSpecifier")
                   (equal node-type "ImportDefaultSpecifier")
                   (equal node-type "ImportNamespaceSpecifier"))
               (babylon-set-face (alist-get 'local node) 'font-lock-variable-name-face))
              ((equal node-type "VariableDeclarator")
               (let* ((var-id (alist-get 'id node))
                      (var-id-type (alist-get 'type var-id)))
                 (if (equal "ObjectPattern" var-id-type)
                     (seq-do
                      (lambda (obj-or-rest-property)
                        (cond ((equal "ObjectProperty" (alist-get 'type obj-or-rest-property))
                               (babylon-set-face (alist-get 'key obj-or-rest-property)
                                                 'font-lock-variable-name-face
                                                 t))
                              ((equal "RestProperty" (alist-get 'type obj-or-rest-property))
                               (babylon-set-face (alist-get 'argument obj-or-rest-property)
                                                 'font-lock-variable-name-face
                                                 t))))
                      (alist-get 'properties var-id))
                   (babylon-set-face var-id 'font-lock-variable-name-face t))))
              ((equal node-type "ClassProperty")
               (babylon-set-face (alist-get 'key node) 'font-lock-variable-name-face))
              ((equal node-type "ClassMethod")
               (babylon-set-face (alist-get 'key node) 'font-lock-variable-name-face))
              ((equal node-type "ObjectTypeProperty")
               (babylon-set-face (alist-get 'value node) 'font-lock-type-face))
              ((equal node-type "BooleanLiteral")
               (babylon-set-face node 'font-lock-constant-face))
              ((equal node-type "NullLiteral")
               (babylon-set-face node 'font-lock-constant-face))
              ((and (equal node-type "Identifier")
                    (seq-contains babylon-js-globals (alist-get 'name node)))
               (babylon-set-face node 'font-lock-builtin-face))
              ((equal node-type "TemplateLiteral")
               (progn
                 (babylon-set-face node 'font-lock-string-face)
                 (seq-do (lambda (elem) (babylon-clear-node-face elem))
                         (alist-get 'expressions node))))
              ((equal node-type "JSXIdentifier")
               (babylon-set-face node 'babylon-jsx-identifier-face2)))
        (cond (traverse-entry (babylon-handle-traverse-table node traverse-entry))
              (t (print node-type))))))

(defconst babylon-js-globals
  '("window"
    "require"
    "document"
    "module"))

(defun babylon-inspect-tok (tok)
  (let ((tok-type (alist-get 'type tok))
        (tok-value (alist-get 'value tok)))
    (cond ((or (equal tok-type "CommentBlock") (equal tok-type "CommentLine"))
           (babylon-set-face tok 'font-lock-comment-face))
          ((and (listp tok-type)
                (equal (alist-get 'label tok-type) "string"))
           (babylon-set-face tok 'font-lock-string-face))
          ((and (listp tok-type)
                (equal (alist-get 'label tok-type) "num"))
           (babylon-set-face tok 'font-lock-constant-face))
          ((or
            (equal tok-value "static")
            (equal tok-value "await"))
           (babylon-set-face tok 'font-lock-keyword-face))
          ((and (listp tok-type) (alist-get 'keyword tok-type))
           (babylon-set-face tok 'font-lock-keyword-face)))))

(defun babylon-parse (file)
  (call-process "node" nil nil nil babylon-script file)
  (let* ((result (json-read-file "/tmp/babylon-parse.json"))
        (tree (alist-get 'body (alist-get 'program result)))
        (toks (alist-get 'tokens result)))
    (with-silent-modifications
      (babylon-clear-face (point-min) (point-max))
      (seq-do 'babylon-inspect-tok toks)
      (seq-do 'babylon-traverse tree))))

(defun babylon-mode ()
  (interactive)
  (kill-all-local-variables)
  (set-syntax-table babylon-mode-syntax-table)
  (use-local-map babylon-mode-map)
  (setq major-mode 'babylon-mode)
  (setq mode-name "babylon")

  ;; for filling, pretend we're cc-mode
  ;; (setq-local comment-start "// ")
  ;; (setq-local comment-end "")
  ;; (setq-local fill-paragraph-function 'c-fill-paragraph)
  ;; (setq c-comment-prefix-regexp "//+\\|\\**"
  ;;       c-paragraph-start "\\(@[[:alpha:]]+\\>\\|$\\)"
  ;;       c-paragraph-separate "$"
  ;;       c-block-comment-prefix "* "
  ;;       c-line-comment-starter "//"
  ;;       c-comment-start-regexp "/[*/]\\|\\s!"
  ;;       comment-start-skip "\\(//+\\|/\\*+\\)\\s *")

  (add-hook 'change-major-mode-hook #'babylon-mode-exit nil t)
  (add-hook 'after-save-hook #'babylon-parse-current-file nil t)

  (run-hooks 'babylon-mode-hook)

  (babylon-parse-current-file))

(defun babylon-parse-current-file ()
  (babylon-parse (buffer-file-name)))

(defun babylon-mode-exit ()
  (with-silent-modifications
    (babylon-clear-face (point-min) (point-max)))
  (remove-hook 'change-major-mode-hook #'babylon-mode-exit t))

(defun babylon-clear-face (beg end)
  (remove-text-properties beg end '(font-lock-face nil
                                    syntax-table nil)))

(with-eval-after-load 'flycheck
  (flycheck-add-mode 'javascript-eslint 'babylon-mode)
  (flycheck-add-mode 'javascript-flow 'babylon-mode))

(add-hook 'babylon-mode-hook 'flycheck-mode)
;; (add-hook 'babylon-mode-hook 'prettier-js-mode)

(provide 'babylon-mode)
